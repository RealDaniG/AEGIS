<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Consciousness Visualization Test</title>
    <link rel="icon" type="image/x-icon" href="/favicon/favicon.ico">
    <link rel="icon" type="image/png" sizes="96x96" href="/favicon/favicon-96x96.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png">
    <link rel="manifest" href="/favicon/site.webmanifest">
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #0a0a1a;
            color: #e0e0e0;
            padding: 20px;
        }
        #consciousness-canvas {
            width: 100%;
            height: 300px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid rgba(192, 132, 252, 0.2);
        }
        .controls {
            margin: 20px 0;
        }
        button {
            padding: 10px 15px;
            background: #c084fc;
            color: #000;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        .info {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <h1>Consciousness Visualization Test</h1>
    
    <div class="info">
        <p>This test page simulates consciousness data to verify the visualization is working correctly.</p>
    </div>
    
    <canvas id="consciousness-canvas"></canvas>
    
    <div class="controls">
        <button onclick="startSimulation()">Start Simulation</button>
        <button onclick="stopSimulation()">Stop Simulation</button>
        <button onclick="testDraw()">Test Single Draw</button>
    </div>
    
    <div id="status"></div>

    <script>
        // Copy the consciousness visualization functions from metatron_integrated.js
        let consciousnessCanvas = null;
        let consciousnessCtx = null;
        let animationFrameId = null;
        let simulationInterval = null;

        function initConsciousnessVisualization() {
            const canvas = document.getElementById('consciousness-canvas');
            if (!canvas) {
                console.warn('Consciousness canvas not found');
                return;
            }
            
            consciousnessCanvas = canvas;
            consciousnessCtx = canvas.getContext('2d');
            
            if (!consciousnessCtx) {
                console.error('Failed to get 2D context for consciousness canvas');
                return;
            }
            
            // Set canvas dimensions
            resizeConsciousnessCanvas();
            
            console.log('Consciousness visualization initialized');
        }

        function resizeConsciousnessCanvas() {
            if (!consciousnessCanvas) return;
            
            // Get the container dimensions
            const container = consciousnessCanvas.parentElement;
            consciousnessCanvas.width = container.clientWidth;
            consciousnessCanvas.height = 300; // Fixed height
        }

        function drawConsciousnessLevel(data) {
            // Validate input data
            if (!data || !data.consciousness) {
                console.warn('Invalid consciousness data for visualization');
                return;
            }
            
            if (!consciousnessCtx || !consciousnessCanvas) {
                console.warn('Consciousness canvas not initialized');
                return;
            }
            
            // Check if canvas has valid dimensions
            if (consciousnessCanvas.width === 0 || consciousnessCanvas.height === 0) {
                resizeConsciousnessCanvas();
            }
            
            const width = consciousnessCanvas.width;
            const height = consciousnessCanvas.height;
            const ctx = consciousnessCtx;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, width, height);
            
            // Get consciousness level (0-1)
            const c = data.consciousness;
            const level = Math.min(1, Math.max(0, c.level || 0));
            const phi = Math.min(1, Math.max(0, c.phi || 0));
            const coherence = Math.min(1, Math.max(0, c.coherence || 0));
            const gamma = Math.min(1, Math.max(0, c.gamma || 0));
            
            // Draw grid
            ctx.strokeStyle = 'rgba(192, 132, 252, 0.1)';
            ctx.lineWidth = 1;
            
            // Vertical grid lines
            for (let i = 0; i <= 10; i++) {
                const x = (width / 10) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            
            // Horizontal grid lines
            for (let i = 0; i <= 5; i++) {
                const y = (height / 5) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // Draw consciousness level as a filled area
            const centerY = height / 2;
            const maxHeight = height * 0.4;
            
            // Draw phi line (blue)
            ctx.beginPath();
            ctx.moveTo(0, centerY - (phi * maxHeight));
            for (let i = 1; i <= 100; i++) {
                const x = (width / 100) * i;
                const t = i / 100;
                const y = centerY - (Math.sin(t * Math.PI * 4 + data.time) * phi * maxHeight * 0.5);
                ctx.lineTo(x, y);
            }
            ctx.strokeStyle = 'rgba(59, 130, 246, 0.7)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw coherence line (green)
            ctx.beginPath();
            ctx.moveTo(0, centerY + (coherence * maxHeight));
            for (let i = 1; i <= 100; i++) {
                const x = (width / 100) * i;
                const t = i / 100;
                const y = centerY + (Math.cos(t * Math.PI * 3 + data.time) * coherence * maxHeight * 0.5);
                ctx.lineTo(x, y);
            }
            ctx.strokeStyle = 'rgba(16, 185, 129, 0.7)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw main consciousness level (purple)
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            for (let i = 1; i <= 100; i++) {
                const x = (width / 100) * i;
                const t = i / 100;
                const wave = Math.sin(t * Math.PI * 2 + data.time) * Math.cos(t * Math.PI * 6 + data.time * 1.5);
                const y = centerY - (level * maxHeight) + (wave * level * maxHeight * 0.3);
                ctx.lineTo(x, y);
            }
            ctx.strokeStyle = 'rgba(192, 132, 252, 1)';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Draw filled area under main consciousness line
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            for (let i = 1; i <= 100; i++) {
                const x = (width / 100) * i;
                const t = i / 100;
                const wave = Math.sin(t * Math.PI * 2 + data.time) * Math.cos(t * Math.PI * 6 + data.time * 1.5);
                const y = centerY - (level * maxHeight) + (wave * level * maxHeight * 0.3);
                ctx.lineTo(x, y);
            }
            ctx.lineTo(width, centerY);
            ctx.closePath();
            const gradient = ctx.createLinearGradient(0, centerY - maxHeight, 0, centerY + maxHeight);
            gradient.addColorStop(0, 'rgba(192, 132, 252, 0.3)');
            gradient.addColorStop(1, 'rgba(192, 132, 252, 0.05)');
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Draw gamma power as small circles
            for (let i = 0; i < 20; i++) {
                const x = (width / 20) * (i + 0.5);
                const t = (i / 20) + data.time * 0.5;
                const y = centerY + Math.sin(t * Math.PI * 8) * maxHeight * 0.7;
                const size = gamma * 5 + 1;
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(251, 191, 36, ${0.3 + gamma * 0.7})`;
                ctx.fill();
            }
            
            // Draw center line
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Draw value labels
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '12px Arial';
            ctx.fillText(`Level: ${level.toFixed(3)}`, 10, 20);
            ctx.fillText(`Î¦: ${phi.toFixed(3)}`, 10, 35);
            ctx.fillText(`Coherence: ${coherence.toFixed(3)}`, 10, 50);
            
            // Draw spiritual value if high
            if (c.spiritual > 0.5) {
                ctx.fillStyle = 'rgba(139, 92, 246, 1)';
                ctx.font = 'bold 14px Arial';
                ctx.fillText(`Spiritual: ${c.spiritual.toFixed(3)}`, width - 120, 20);
            }
        }

        // Test functions
        function testDraw() {
            const testData = {
                time: Date.now() / 1000,
                consciousness: {
                    level: 0.75,
                    phi: 0.65,
                    coherence: 0.82,
                    gamma: 0.71,
                    spiritual: 0.58,
                    depth: 3,
                    fractal_dim: 1.618,
                    state: "aware",
                    is_conscious: true
                },
                nodes: {}
            };
            
            drawConsciousnessLevel(testData);
            document.getElementById('status').innerHTML = '<p>Test draw completed. Check canvas above.</p>';
        }

        function startSimulation() {
            if (simulationInterval) {
                clearInterval(simulationInterval);
            }
            
            simulationInterval = setInterval(() => {
                const time = Date.now() / 1000;
                const testData = {
                    time: time,
                    consciousness: {
                        level: 0.5 + 0.3 * Math.sin(time * 0.5),
                        phi: 0.4 + 0.4 * Math.cos(time * 0.3),
                        coherence: 0.6 + 0.3 * Math.sin(time * 0.7),
                        gamma: 0.5 + 0.4 * Math.cos(time * 0.4),
                        spiritual: 0.3 + 0.5 * Math.sin(time * 0.2),
                        depth: Math.floor(5 * Math.sin(time * 0.1)) + 3,
                        fractal_dim: 1.618 + 0.1 * Math.sin(time * 0.6),
                        state: "aware",
                        is_conscious: true
                    },
                    nodes: {}
                };
                
                drawConsciousnessLevel(testData);
            }, 50);
            
            document.getElementById('status').innerHTML = '<p>Simulation running. Canvas should be updating...</p>';
        }

        function stopSimulation() {
            if (simulationInterval) {
                clearInterval(simulationInterval);
                simulationInterval = null;
            }
            document.getElementById('status').innerHTML = '<p>Simulation stopped.</p>';
        }

        // Initialize on load
        window.addEventListener('load', () => {
            initConsciousnessVisualization();
            document.getElementById('status').innerHTML = '<p>Visualization system initialized. Click "Test Single Draw" to verify.</p>';
        });
    </script>
</body>
</html>